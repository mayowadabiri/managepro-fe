  useEffect(() => {
    // Check if user is logged in on initial load
    const storedUser = localStorage.getItem('subtracker_user');
    if (storedUser) {
      setUser(JSON.parse(storedUser));
    }
    setIsLoading(false);
  }, []);
  const login = async (email: string, password: string, rememberMe = false): Promise<boolean> => {
    setIsLoading(true);
    // Simulate API call
    return new Promise(resolve => {
      setTimeout(() => {
        // Get users from localStorage
        const users = JSON.parse(localStorage.getItem('subtracker_users') || '[]');
        const foundUser = users.find((u: any) => u.email === email && u.password === password);
        if (foundUser) {
          // Create a user object without the password
          const loggedInUser = {
            id: foundUser.id,
            firstName: foundUser.firstName,
            lastName: foundUser.lastName,
            email: foundUser.email,
            phoneNumber: foundUser.phoneNumber
          };
          // Store in localStorage and update state
          localStorage.setItem('subtracker_user', JSON.stringify(loggedInUser));
          // If remember me is checked, set a longer expiration
          if (rememberMe) {
            // This is a mock implementation - in a real app, you would use cookies or tokens with expiration
            localStorage.setItem('subtracker_remember', 'true');
          }
          setUser(loggedInUser);
          setIsLoading(false);
          resolve(true);
        } else {
          setIsLoading(false);
          resolve(false);
        }
      }, 1000); // Simulate network delay
    });
  };
  const signup = async (firstName: string, lastName: string, email: string, phoneNumber: string, password: string): Promise<boolean> => {
    setIsLoading(true);
    // Simulate API call
    return new Promise(resolve => {
      setTimeout(() => {
        // Get existing users
        const users = JSON.parse(localStorage.getItem('subtracker_users') || '[]');
        // Check if email already exists
        const emailExists = users.some((u: any) => u.email === email);
        if (emailExists) {
          setIsLoading(false);
          resolve(false);
          return;
        }
        // Create new user
        const newUser = {
          id: Date.now().toString(),
          firstName,
          lastName,
          email,
          phoneNumber,
          password,
          verified: false // Users need to verify OTP
        };
        // Add to users array
        users.push(newUser);
        localStorage.setItem('subtracker_users', JSON.stringify(users));
        // In a real app, we would send an OTP to the user's email or phone
        // For mock purposes, we'll store the OTP in localStorage
        const otp = Math.floor(100000 + Math.random() * 900000).toString();
        const otps = JSON.parse(localStorage.getItem('subtracker_otps') || '{}');
        otps[email] = {
          code: otp,
          expires: Date.now() + 10 * 60 * 1000,
          purpose: 'signup'
        };
        localStorage.setItem('subtracker_otps', JSON.stringify(otps));
        // Log the OTP to console for testing purposes
        console.log(`OTP for ${email}: ${otp}`);
        setIsLoading(false);
        resolve(true);
      }, 1000); // Simulate network delay
    });
  };
  const requestPasswordReset = async (email: string): Promise<boolean> => {
    setIsLoading(true);
    return new Promise(resolve => {
      setTimeout(() => {
        // Check if the email exists in our users
        const users = JSON.parse(localStorage.getItem('subtracker_users') || '[]');
        const userExists = users.some((u: any) => u.email === email);
        if (!userExists) {
          setIsLoading(false);
          resolve(false);
          return;
        }
        // Generate and store OTP
        const otp = Math.floor(100000 + Math.random() * 900000).toString();
        const otps = JSON.parse(localStorage.getItem('subtracker_otps') || '{}');
        otps[email] = {
          code: otp,
          expires: Date.now() + 10 * 60 * 1000,
          purpose: 'reset'
        };
        localStorage.setItem('subtracker_otps', JSON.stringify(otps));
        // Log the OTP to console for testing purposes
        console.log(`Password Reset OTP for ${email}: ${otp}`);
        setIsLoading(false);
        resolve(true);
      }, 1000);
    });
  };
  const verifyOtp = async (email: string, otpInput: string): Promise<boolean> => {
    setIsLoading(true);
    return new Promise(resolve => {
      setTimeout(() => {
        // Get stored OTPs
        const otps = JSON.parse(localStorage.getItem('subtracker_otps') || '{}');
        const storedOtpData = otps[email];
        if (!storedOtpData) {
          setIsLoading(false);
          resolve(false);
          return;
        }
        // Check if OTP is expired
        if (Date.now() > storedOtpData.expires) {
          // Remove expired OTP
          delete otps[email];
          localStorage.setItem('subtracker_otps', JSON.stringify(otps));
          setIsLoading(false);
          resolve(false);
          return;
        }
        // Verify OTP
        if (storedOtpData.code === otpInput) {
          // If this is for signup, mark the user as verified
          if (storedOtpData.purpose === 'signup') {
            const users = JSON.parse(localStorage.getItem('subtracker_users') || '[]');
            const userIndex = users.findIndex((u: any) => u.email === email);
            if (userIndex !== -1) {
              users[userIndex].verified = true;
              localStorage.setItem('subtracker_users', JSON.stringify(users));
              // Log in the user
              const verifiedUser = {
                id: users[userIndex].id,
                firstName: users[userIndex].firstName,
                lastName: users[userIndex].lastName,
                email: users[userIndex].email,
                phoneNumber: users[userIndex].phoneNumber
              };
              localStorage.setItem('subtracker_user', JSON.stringify(verifiedUser));
              setUser(verifiedUser);
            }
          }
          // Keep the OTP for reset password flow, remove for signup
          if (storedOtpData.purpose !== 'reset') {
            delete otps[email];
            localStorage.setItem('subtracker_otps', JSON.stringify(otps));
          }
          setIsLoading(false);
          resolve(true);
        } else {
          setIsLoading(false);
          resolve(false);
        }
      }, 1000);
    });
  };
  const resetPassword = async (email: string, otp: string, newPassword: string): Promise<boolean> => {
    setIsLoading(true);
    return new Promise(resolve => {
      setTimeout(() => {
        // Verify OTP first
        const otps = JSON.parse(localStorage.getItem('subtracker_otps') || '{}');
        const storedOtpData = otps[email];
        if (!storedOtpData || storedOtpData.code !== otp || Date.now() > storedOtpData.expires || storedOtpData.purpose !== 'reset') {
          setIsLoading(false);
          resolve(false);
          return;
        }
        // Update the password
        const users = JSON.parse(localStorage.getItem('subtracker_users') || '[]');
        const userIndex = users.findIndex((u: any) => u.email === email);
        if (userIndex !== -1) {
          users[userIndex].password = newPassword;
          localStorage.setItem('subtracker_users', JSON.stringify(users));
          // Remove the used OTP
          delete otps[email];
          localStorage.setItem('subtracker_otps', JSON.stringify(otps));
          setIsLoading(false);
          resolve(true);
        } else {
          setIsLoading(false);
          resolve(false);
        }
      }, 1000);
    });
  };
  const logout = () => {
    localStorage.removeItem('subtracker_user');
    localStorage.removeItem('subtracker_remember');
    setUser(null);
  };